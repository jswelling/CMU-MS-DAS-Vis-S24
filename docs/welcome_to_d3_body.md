## Welcome To D3

[D3](https://d3js.org/)
is a set of tools for drawing dynamic visualizations in a browser.
The results can be beautiful and very effective, but the recipes are
messy and difficult to teach.  

D3 stands for 'Data-driven documents'.

Much of the code is Javascript on the web page itself.  It's rather
idiomatic and has a style that seems unusual to me.


Since serious javascript is outside the domain of this course, we are going
to look at the structure of D3 applications without trying to fully understand
all the details.

This means our visit to D3 must stay pretty superficial.



### First some examples

There are many at [The ObservableHQ Gallery](https://observablehq.com/@d3/gallery).

See also [the D3 Home Page](https://d3js.org/)


* [Force-directed graph](https://observablehq.com/@d3/force-directed-graph)
* [Disconnected graph](https://observablehq.com/@d3/disjoint-force-directed-graph)
* [Treemap](https://observablehq.com/@d3/treemap)
* [Zoomable treemap](https://observablehq.com/@d3/zoomable-treemap)
* [Sortable bar chart](https://observablehq.com/@d3/bar-chart-transitions)
* [Tidy tree](https://observablehq.com/@d3/tree)
* [Icicle graph (zoomable!)](https://observablehq.com/@d3/zoomable-icicle)
* [Sankey diagram](https://observablehq.com/@d3/sankey) (see also the [HuBMAP data queue](https://software.docs.hubmapconsortium.org/data-sankey/index.html))


Keep in mind, each of these is a sort of recipe.  You can copy it and
customize it, but it's not as plug-and-play as, say, seaborn.



### How does it work?

Consider this simple example from earlier:

![simple graph, done with SVG](images/simple_graph_svg_example.png)


#### The SVG for this graph

```
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="89pt" height="188pt"
 viewBox="0.00 0.00 89.00 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>%3</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-184 85,-184 85,4 -4,4"/>
<!-- A -->
<g id="node1" class="node">
<title>A</title>
<ellipse fill="none" stroke="#000000" cx="54" cy="-162" rx="27" ry="18"/>
<text text-anchor="middle" x="54" y="-158.3" font-family="Times,serif" font-size="14.00" fill="#000000">A</text>
</g>
<!-- B -->
<g id="node2" class="node">
<title>B</title>
<ellipse fill="none" stroke="#000000" cx="27" cy="-90" rx="27" ry="18"/>
<text text-anchor="middle" x="27" y="-86.3" font-family="Times,serif" font-size="14.00" fill="#000000">B</text>
</g>
<!-- A&#45;&gt;B -->
<g id="edge1" class="edge">
<title>A&#45;&gt;B</title>
<path fill="none" stroke="#000000" d="M47.3258,-144.2022C44.2524,-136.0064 40.5384,-126.1024 37.1305,-117.0145"/>
<polygon fill="#000000" stroke="#000000" points="40.3858,-115.7274 33.5974,-107.593 33.8315,-118.1853 40.3858,-115.7274"/>
</g>
<!-- C -->
<g id="node3" class="node">
<title>C</title>
<ellipse fill="none" stroke="#000000" cx="54" cy="-18" rx="27" ry="18"/>
<text text-anchor="middle" x="54" y="-14.3" font-family="Times,serif" font-size="14.00" fill="#000000">C</text>
</g>
<!-- B&#45;&gt;C -->
<g id="edge2" class="edge">
<title>B&#45;&gt;C</title>
<path fill="none" stroke="#000000" d="M33.6742,-72.2022C36.7476,-64.0064 40.4616,-54.1024 43.8695,-45.0145"/>
<polygon fill="#000000" stroke="#000000" points="47.1685,-46.1853 47.4026,-35.593 40.6142,-43.7274 47.1685,-46.1853"/>
</g>
<!-- C&#45;&gt;A -->
<g id="edge3" class="edge">
<title>C&#45;&gt;A</title>
<path fill="none" stroke="#000000" d="M57.7474,-35.9069C59.7466,-46.3759 61.9966,-59.8759 63,-72 64.3197,-87.9455 64.3197,-92.0545 63,-108 62.2945,-116.5247 60.9727,-125.7297 59.5551,-134.083"/>
<polygon fill="#000000" stroke="#000000" points="56.0803,-133.6302 57.7474,-144.0931 62.9689,-134.8742 56.0803,-133.6302"/>
</g>
</g>
</svg>
```


It looks like XML (or HTML) because it is.  When this gets inserted into
the browser page, the individual bits of the SVG structure exist as
separate entities in the browser DOM.

Let's look at this bit of SVG in the browser's developer tools.  We have
to use the Flask app because Streamlit hides the structure.


We are used to javascript being able to change the normal elements of
HTML.  In D3, the javascript directly accesses the elements of an SGV
graph, setting them and modifying them to create the visualization.



### Why is this necessary?

It takes somewhere between 100ms and a few seconds for the browser
to pass info to the web server and get a reply.  For fully interactive
visualization in a browser, that's just too slow.

To be fully interactive, the server needs to send the data and then
leave the entire job of interactive display to code in the browser.
That means it has to be javascript.


Interactivity is *key*.  It provides a whole new channel of interaction
with the visualization.  Consider
[Observable's Brushable Scatterplot](https://observablehq.com/@d3/brushable-scatterplot-matrix?intent=fork) .
That level of interaction is impossible if every action must be transmitted back to the server.


This doesn't explain why the work of setting up the visualization isn't
more 'packaged'.  I don't understand this.  Maybe some D3 visualizations
are, but most of the ones I've looked at are not.



### One easily-accessible example

The [d3graph](https://github.com/erdogant/d3graph) package by
[Erdogant](https://github.com/erdogant) is an encapsulation of the D3.js force-directed
graph javascript in python.  Given a static graph in the form of an adjacency matrix,
it writes and saves an HTML page to display it using D3.

You can then just display that HTML.  There is even a special wrapper to show it in
Streamlit.


I tried for a notebook to do this last night, and almost got it working.



### Let's look at the details of an example in Flask

The *d3_support* branch of our Flask server can build and dispay a
Treemap.  Let's look in some detail at the code.

The Flask side just passes data to the browser in response to the
'submit' button.  The interesting parts are all on the browser side.


#### Steps implemented in javascript

Assuming the AJAX request for data happens successfully, the
javascript code in the browser takes the following steps:
* Delete the old graph.
* Construct a new, empty SVG element inside which the new graph gets built.
* Generate a Hierarchy, a D3 datastructure used for Treemaps and other things.
* The *d3.treemap()* call adds info about the layout of rectangles to the Hierarchy.


...continuing...

* The rectangles and text labels get built by looping over the size and location data in the Hierarchy.

Once all this is done, the Treemap appears on screen.
